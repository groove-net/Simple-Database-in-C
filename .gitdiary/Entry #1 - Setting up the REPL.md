# Sqlite

There’s lots of [documentation of sqlite internals](https://www.sqlite.org/arch.html) on their website, plus I’ve got a copy of [SQLite Database System: Design and Implementation](https://play.google.com/store/books/details?id=9Z6IQQnX1JEC).

![sqlite architecture (https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)](https://cstack.github.io/db_tutorial/assets/images/arch1.gif)

A query goes through a chain of components in order to retrieve or modify data. The **front-end** consists of the:

- tokenizer
- parser
- code generator

The input to the front-end is a SQL query. The output of the front-end is sqlite virtual machine bytecode (essentially a compiled program that can operate on the database).

The *back-end* consists of the:

- Virtual machine: The virtual machine takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction.
- **B-tree**: Each B-tree consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager.
- Pager: The pager receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk.
- Os Interface: The os interface is the layer that differs depending on which operating system sqlite was compiled for. In this tutorial, I’m not going to support multiple platforms.

### The main loop

Sqlite starts a read-execute-print loop when you start it from the command line:

```bash
**$** sqlite3
SQLite version 3.16.0 2016-11-04 19:09:39
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> create table users (id int, username varchar(255), email varchar(255));
sqlite> .tables
users
sqlite> .exit
**$**
```

Here’s how we can achieve this:

 In a new C project, we’ll define `InputBuffer` struct as a small wrapper around the state we need to store to interact with user commands. We only need one global instance of this struct.

```c
/*
 ============================================================================
 Name        : Simple Database In C
 Author      : Gabriel Adelemoni
 Version     : 1.0
 Description : A simple C application demonstrating project structure with
               src, include, Makefile-based build system, and modular design.
               Uses static libraries and includes dependency management.
 License     : MIT
 ============================================================================
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
  char* buffer;
  size_t buffer_length;
  ssize_t input_length;
} InputBuffer;

InputBuffer* input_buffer;

**int** **main**() {
  return 0;
}
```

Next, let’s define an `_setup()` function that initliazes our `input_buffer` on program start.

```c
**void _setup**() {
  input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));
  input_buffer->buffer = NULL;
  input_buffer->buffer_length = 0;
  input_buffer->input_length = 0;
}

**int** **main**() {
  **_setup**();
  return 0;
}
```

Our main function will have an infinite loop that (1) waits for input from the shell, i.e. standard input, and reads a line of input when available, then (2) processes that line of input. To achieve the first task, we will be using the  [getline()](http://man7.org/linux/man-pages/man3/getline.3.html) function:

```c
**ssize_t** **getline**(**char** ******lineptr, **size_t** *****n, **FILE** *****stream);
```

- `lineptr` : a pointer to the variable we use to point to the buffer containing the read line. If it set to `NULL` it is mallocatted by `getline` and should thus be freed by the user, even if the command fails.
- `n` : a pointer to the variable we use to save the size of allocated buffer.
- `stream` : the input stream to read from. We’ll be reading from standard input.
- `return value` : the number of bytes read, which may be less than the size of the buffer.

`getline` is a blocking call. This means that the main thread sleeps until data from the standard input is available to read. Once available, we tell `getline` to store the read line in `input_buffer->buffer` and the size of the allocated buffer in `input_buffer->buffer_length`. We store the return value in `input_buffer->input_length`.

`buffer` starts as null, so `getline` allocates enough memory to hold the line of input and makes `buffer` point to it. 

We can create a wrapping function around `getline` procedure called `read_input`. This will make our main loop cleaner.

```c
**.
.
.
void read_input**() 
{
  ssize_t bytes_read = getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);

  if (bytes_read <= 0) 
  {
    printf("Error reading input\n");
    exit(EXIT_FAILURE);
  }

  // Ignore trailing newlineinput_buffer->input_length = bytes_read - 1;
  input_buffer->buffer[bytes_read - 1] = 0;
}

int **main**()
{
  _setup();
  while (true) 
  {
    printf("db > ");
    read_input();
  }
}
```

At this point, running the application lets the user can enter random “commands” in the terminal. Each command overrides the `input_buffer->buffer` but we aren’t doing any processing yet. There is also no way to exit the application except for forcing an interrupt with `<Ctrl>-C`.

```bash
**$** ./db
db **>** .hello
db **>** .small
db **>** .world
db **>** ^C
**$**
```

Below, is an example of how we parse and execute user commands. There is only one recognized command right now : `.exit`, which terminates the program. Otherwise we print an error message and continue the loop.

```c
.
.
.
int **main**()
{
  _setup();
  while (true) 
  {
    printf("db > ");
    read_input();

    if (strcmp(input_buffer->buffer, ".exit") == 0) exit(EXIT_SUCCESS);
    else printf("Unrecognized command '%s'.\n", input_buffer->buffer);
  }
}
```

Let’s try it out!

```bash
**$** ./db
db **>** .tables
Unrecognized command '.tables'.
db **>** .exit
**$**
```

Alright, we’ve got a working REPL. In the next part, we’ll start developing our command language. Meanwhile, here’s the entire program from this part:

```c
/*
 ============================================================================
 Name        : Simple Database In C
 Author      : Gabriel Adelemoni
 Version     : 1.0
 Description : A simple C application demonstrating project structure with
               src, include, Makefile-based build system, and modular design.
               Uses static libraries and includes dependency management.
 License     : MIT
 ============================================================================
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
  char* buffer;
  size_t buffer_length;
  ssize_t input_length;
} InputBuffer;

InputBuffer* input_buffer;

void _setup() 
{
  input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));
  input_buffer->buffer = NULL;
  input_buffer->buffer_length = 0;
  input_buffer->input_length = 0;
}

void read_input() 
{
  ssize_t bytes_read =getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);

  if (bytes_read <= 0) 
  {
    printf("Error reading input\n");
    exit(EXIT_FAILURE);
  }

  // Ignore trailing newlineinput_buffer->input_length = bytes_read - 1;
  input_buffer->buffer[bytes_read - 1] = 0;
}

int main()
{
  _setup();
  while (true) 
  {
    printf("db > ");
    read_input();

    if (strcmp(input_buffer->buffer, ".exit") == 0) exit(EXIT_SUCCESS);
    else printf("Unrecognized command '%s'.\n", input_buffer->buffer);
  }
}

```